# Звіт: Інтеграція паттернів проєктування

## Мета роботи

Демонстрація інтеграції кількох паттернів проєктування в єдиній архітектурі для обробки та логування даних з динамічною зміною поведінки.

---

## 1. Використані паттерни проєктування

### 1.1 Паттерн Singleton (Одинак)

**Місцезнаходження:** Клас `LoggerManager`

**Описання:**
Паттерн Singleton забезпечує, що клас має лише один екземпляр, і надає глобальну точку доступу до нього.

**Реалізація:**
```csharp
public class LoggerManager
{
    private static LoggerManager? instance;
    private LoggerFactory factory;

    private LoggerManager(LoggerFactory factory) => this.factory = factory;

    public static LoggerManager GetInstance(LoggerFactory factory)
    {
        if (instance == null)
            instance = new LoggerManager(factory);
        return instance;
    }
}
```

**Обґрунтування:**
- Гарантує единість точки логування в програмі
- Запобігає створенню кількох конфліктуючих екземплярів
- Дозволяє глобальний доступ до логера з будь-якої частини коду

**Переваги:**
- Контрольована ініціалізація
- Глобальна точка доступу
- Ефективне використання ресурсів

---

### 1.2 Паттерн Factory (Фабрика)

**Місцезнаходження:** Класи `LoggerFactory`, `ConsoleLoggerFactory`, `FileLoggerFactory`

**Описання:**
Паттерн Factory надає інтерфейс для створення об'єктів без зазначення їхніх конкретних класів.

**Реалізація:**
```csharp
public abstract class LoggerFactory
{
    public abstract ILogger CreateLogger();
}

public class ConsoleLoggerFactory : LoggerFactory
{
    public override ILogger CreateLogger() => new ConsoleLogger();
}

public class FileLoggerFactory : LoggerFactory
{
    public override ILogger CreateLogger() => new FileLogger();
}
```

**Обґрунтування:**
- Відокремлює код створення об'єктів від їхнього використання
- Дозволяє легко додавати нові типи логерів без изменення існуючого коду
- Забезпечує гнучкість та розширюваність

**Взаємодія з Singleton:**
`LoggerManager` використовує `LoggerFactory` для створення екземплярів логерів, дозволяючи динамічну заміну реалізацій без зміни клієнтського коду:
```csharp
loggerManager.SetFactory(new FileLoggerFactory());
```

---

### 1.3 Паттерн Strategy (Стратегія)

**Місцезнаходження:** Інтерфейс `IDataProcessorStrategy` та його реалізації

**Описання:**
Паттерн Strategy визначає сімейство алгоритмів, інкапсулює кожен з них і робить їх взаємозамінюваними.

**Реалізація:**
```csharp
public interface IDataProcessorStrategy
{
    string Process(string data);
}

public class EncryptDataStrategy : IDataProcessorStrategy
{
    public string Process(string data) => 
        $"[Encrypted] {Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(data))}";
}

public class CompressDataStrategy : IDataProcessorStrategy
{
    public string Process(string data) => 
        $"[Compressed] {string.Join("", data.Distinct())}";
}
```

**Обґрунтування:**
- Різні алгоритми обробки можуть вибиратись на етапі виконання
- Дозволяє змінювати алгоритм без впливу на основний код
- Легко розширювати новими стратегіями

**Використання в контексті:**
```csharp
public class DataContext
{
    private IDataProcessorStrategy strategy;

    public void SetStrategy(IDataProcessorStrategy strategy) => 
        this.strategy = strategy;

    public string Execute(string data) => strategy.Process(data);
}
```

---

### 1.4 Паттерн Observer (Спостерігач)

**Місцезнаходження:** Класи `DataPublisher` та `ProcessingLoggerObserver`

**Описання:**
Паттерн Observer визначає залежність "один до багатьох" так, що коли один об'єкт змінює стан, всі залежні від нього об'єкти сповіщаються про це автоматично.

**Реалізація:**
```csharp
public class DataPublisher
{
    public event Action<string>? DataProcessed;
    public void PublishDataProcessed(string data) => DataProcessed?.Invoke(data);
}

public class ProcessingLoggerObserver
{
    public ProcessingLoggerObserver(DataPublisher publisher)
    {
        publisher.DataProcessed += OnDataProcessed;
    }

    private void OnDataProcessed(string data)
    {
        LoggerManager.GetInstance(new ConsoleLoggerFactory())
            .Log($"Observer received processed data: {data}");
    }
}
```

**Обґрунтування:**
- Слабко зв'язана архітектура: видавець не знає про спостерігачів
- Дозволяє динамічно додавати/видаляти спостерігачів
- Автоматичне сповіщення при змінах

**Інтеграція з іншими паттернами:**
Спостерігач отримує сповіщення та використовує Singleton для доступу до LoggerManager'а

---

## 2. Архітектура інтеграції

### 2.1 Схема взаємодії компонентів

```
┌─────────────────────────────────────────────────────────┐
│                     Main Program                         │
└──────────────┬──────────────────────────────────────────┘
               │
       ┌───────┴───────────────┬─────────────────────┐
       │                       │                     │
       ▼                       ▼                     ▼
┌─────────────────┐  ┌──────────────────┐  ┌────────────────┐
│ LoggerManager   │  │  DataContext     │  │ DataPublisher  │
│  (Singleton)    │  │  (Strategy)      │  │  (Observer)    │
└────────┬────────┘  └────────┬─────────┘  └────────┬───────┘
         │                    │                     │
         ▼                    ▼                     ▼
    ┌─────────────┐  ┌──────────────┐  ┌─────────────────────┐
    │LoggerFactory│  │  Strategy    │  │ProcessingLogger     │
    │  (Factory)  │  │  (Strategy)  │  │Observer (Observer)  │
    └─────────────┘  └──────────────┘  └─────────────────────┘
         │                    │
    ┌────┴────┐           ┌───┴────┐
    │          │           │        │
    ▼          ▼           ▼        ▼
  Console  FileLogger  Encrypt Compress
  Logger            Strategy Strategy
```

### 2.2 Потік виконання

**Сценарій 1 - Повна інтеграція:**
1. Створюється `LoggerManager` з `ConsoleLoggerFactory`
2. Створюється `DataContext` з `EncryptDataStrategy`
3. Створюється `DataPublisher` та `ProcessingLoggerObserver`
4. Спостерігач підписується на событие `DataProcessed`
5. Дані обробляються стратегією шифрування
6. Результат логується через LoggerManager
7. Видавець сповіщає спостерігала про обробку

**Сценарій 2 - Динамічна зміна логера:**
1. Викликається `loggerManager.SetFactory(new FileLoggerFactory())`
2. Тепер логування записується у файл
3. Архітектура залишається незмінною

**Сценарій 3 - Динамічна зміна стратегії:**
1. Викликається `context.SetStrategy(new CompressDataStrategy())`
2. Дані обробляються новою стратегією
3. Результат передається логеру та спостерігачу

---

## 3. Обґрунтування дизайну

### 3.1 SOLID принципи

**Single Responsibility Principle (S):**
- `Console/FileLogger` - відповідають лише за логування в конкретне місце
- `EncryptDataStrategy/CompressDataStrategy` - відповідають за конкретні алгоритми
- `LoggerManager` - управління логерами
- `DataContext` - управління стратегіями

**Open/Closed Principle (O):**
- Система відкрита для розширення (легко додати новий логер або стратегію)
- Закрита для модифікації (змін у існуючий код Singleton/Strategy не впливають)

**Liskov Substitution Principle (L):**
- Будь-яка реалізація `ILogger` може замінити іншу
- Будь-яка реалізація `IDataProcessorStrategy` може замінити іншу

**Interface Segregation Principle (I):**
- Клієнти залежать від мінімальних інтерфейсів (`ILogger`, `IDataProcessorStrategy`)
- Клієнти не змушені залежати від непотрібних методів

**Dependency Inversion Principle (D):**
- Залежність на абстракціях (`ILogger`, `IDataProcessorStrategy`), а не на конкретних класах
- Впровадження залежностей через конструктори та сетери

### 3.2 Переваги архітектури

1. **Гнучкість:** Легко змінювати поведінку на етапі виконання
2. **Розширюваність:** Нові алгоритми та логери додаються без змін існуючого коду
3. **Тестованість:** Легко мокувати залежності для unit-тестів
4. **Слабка зв'язаність:** Компоненти незалежні один від одного
5. **Масштабованість:** Архітектура готова до розширення

---

## 4. Практичні приклади

### Приклад 1: Додавання нового логера

Щоб додати логування через мережу, достатньо:
```csharp
public class NetworkLogger : ILogger
{
    public void Log(string message) => SendToServer(message);
}

public class NetworkLoggerFactory : LoggerFactory
{
    public override ILogger CreateLogger() => new NetworkLogger();
}

// Використання:
loggerManager.SetFactory(new NetworkLoggerFactory());
```

### Приклад 2: Додавання нової стратегії обробки

Щоб додати стиснення даних, достатньо:
```csharp
public class CompressionStrategy : IDataProcessorStrategy
{
    public string Process(string data) => CompressData(data);
}

// Використання:
context.SetStrategy(new CompressionStrategy());
```

---

## 5. Висновки

Дана архітектура демонструє успішну інтеграцію кількох паттернів проєктування:

1. **Singleton** гарантує единість управління ресурсами
2. **Factory** забезпечує гнучке створення об'єктів
3. **Strategy** дозволяє динамічно змінювати алгоритми
4. **Observer** реалізує слабко зв'язану комунікацію

Ці паттерни працюють синергетично, створюючи систему, яка:
- Легко розширюється
- Добре тестується
- Дотримується SOLID принципів
- Готова до зростання

Такий підхід корисний для більших систем, де часто потрібна заміна реалізацій та додавання нових функцій без впливу на існуючий код.

---

## 6. Рекомендації

1. **Потокобезпека Singleton:** Для многопоточного середовища розглянути `lock` механізм
2. **Обробка помилок:** Додати обробку виключень у логерах та стратегіях
3. **Конфігурація:** Використати конфігураційні файли для вибору фабрик
4. **Логування:** Додати рівні логування (Debug, Info, Warning, Error)
5. **Кешування:** Розглянути кешування результатів обробки для оптимізації

---

**Дата:** 25 лютого 2026  
**Автор:** Software Architecture Analysis  
**Мова:** Українська
